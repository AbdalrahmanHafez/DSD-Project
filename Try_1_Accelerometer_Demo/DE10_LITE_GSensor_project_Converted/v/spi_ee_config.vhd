--------------------------------------------------------------
--------------------------------------------------------------
--                                                          --
-- This VHDL file has been generated by the verilog2vhdl    --
-- tool.                                                    --
-- Contact help@edautils.com  for support/info.--
--                                                          --
--                                                          --
--------------------------------------------------------------
--------------------------------------------------------------
--
--
-- Assumptions: 
--         (1) All the parameters are of type INTEGER, and hence the translated generics are of this type
--
--
-- Generated by : apache on 2/19/21 2:23 PM
--
--
library ieee;
use ieee.std_logic_1164.all;
package vl2vh_common_pack_spi_ee_config is 
    type vl2vh_memory_type is      array  ( natural range <> , natural range <>  )  of std_logic ;
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic;  constant falseval : std_logic)  return std_logic; 
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic_vector;  constant falseval : std_logic_vector)  return std_logic_vector; 
end package; 




package body vl2vh_common_pack_spi_ee_config is 
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic;  constant falseval : std_logic)  return std_logic is 
    begin
        if ( cond ) then 
             return trueval;
        else 
             return falseval;
        end if;
    end;
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic_vector;  constant falseval : std_logic_vector)  return std_logic_vector is 
    begin
        if ( cond ) then 
             return trueval;
        else 
             return falseval;
        end if;
    end;
end; 


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.std_logic_misc.all;
use ieee.numeric_std.all;
use work.vl2vh_common_pack_spi_ee_config.all;
entity spi_controller is 
     port (
        iRSTN :  in std_logic;
        iSPI_CLK :  in std_logic;
        iSPI_CLK_OUT :  in std_logic;
        iP2S_DATA :  inout std_logic;
        iSPI_GO :  inout std_logic;
        oSPI_END :  inout std_logic;
        oS2P_DATA :  inout std_logic;
        SPI_SDIO :  inout std_logic;
        oSPI_CSN :  out std_logic;
        oSPI_CLK :  out std_logic
    );
end entity; 


architecture rtl of spi_controller is 
    begin 
    end; 


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.std_logic_misc.all;
use ieee.numeric_std.all;
use ieee.std_logic_arith.all;
use work.vl2vh_common_pack_spi_ee_config.all;
entity spi_ee_config_spi_ee_config is 
     port (
        iRSTN :  in std_logic;
        iSPI_CLK :  in std_logic;
        iSPI_CLK_OUT :  in std_logic;
        iG_INT2 :  in std_logic;
        oDATA_L :  out std_logic_vector( 1 downto 0  );
        oDATA_H :  out std_logic_vector( 1 downto 0  );
        SPI_SDIO :  inout std_logic;
        oSPI_CSN :  out std_logic;
        oSPI_CLK :  out std_logic
    );
end entity; 


architecture rtl of spi_ee_config_spi_ee_config is 
    signal SO_DataL : std_logic;
    signal ini_index : std_logic_vector( 3  downto 0  );
    signal SI_DataL : std_logic;
    signal write_data : std_logic_vector( ( SI_DataL - 2  )  downto 0  );
    signal p2s_data : std_logic_vector( SI_DataL downto 0  );
    signal spi_go : std_logic;
    signal spi_end : std_logic;
    signal s2p_data : std_logic_vector( SO_DataL downto 0  );
    signal low_byte_data : std_logic_vector( SO_DataL downto 0  );
    signal spi_state : std_logic;
    signal high_byte : std_logic;
    signal read_back : std_logic;
    signal clear_status : std_logic;
    signal read_ready : std_logic;
    signal clear_status_d : std_logic_vector( 3  downto 0  );
    signal high_byte_d : std_logic;
    signal read_back_d : std_logic;
    signal IDLE_MSB : std_logic;
    signal read_idle_count : std_logic_vector( IDLE_MSB downto 0  );
    signal THRESH_ACT : std_logic;
    signal THRESH_INACT : std_logic;
    signal TIME_INACT : std_logic;
    signal ACT_INACT_CTL : std_logic;
    signal THRESH_FF : std_logic;
    signal TIME_FF : std_logic;
    signal BW_RATE : std_logic;
    signal INT_ENABLE : std_logic;
    signal INT_MAP : std_logic;
    signal DATA_FORMAT : std_logic;
    signal POWER_CONTROL : std_logic;
    signal IDLE : std_logic;
    signal INI_NUMBER : std_logic;
    signal WRITE_MODE : std_logic;
    signal TRANSFER : std_logic;
    signal READ_MODE : std_logic;
    signal X_HB : std_logic;
    signal X_LB : std_logic;
    signal INT_SOURCE : std_logic;
    component spi_controller is 
         port (
            iRSTN :  in std_logic;
            iSPI_CLK :  in std_logic;
            iSPI_CLK_OUT :  in std_logic;
            iP2S_DATA :  inout std_logic;
            iSPI_GO :  inout std_logic;
            oSPI_END :  inout std_logic;
            oS2P_DATA :  inout std_logic;
            SPI_SDIO :  inout std_logic;
            oSPI_CSN :  out std_logic;
            oSPI_CLK :  out std_logic
        );
    end component; 
    begin 
        u_spi_controller : spi_controller
            port map (
                SPI_SDIO => SPI_SDIO,
                iP2S_DATA => p2s_data,
                iRSTN => iRSTN,
                iSPI_CLK => iSPI_CLK,
                iSPI_CLK_OUT => iSPI_CLK_OUT,
                iSPI_GO => spi_go,
                oS2P_DATA => s2p_data,
                oSPI_CLK => oSPI_CLK,
                oSPI_CSN => oSPI_CSN,
                oSPI_END => spi_end
                );
        process 
        begin
            wait  on ini_index;
            case  ( ini_index ) is 
                when 
                    0  => 
                    write_data <= ( THRESH_ACT & X"20"  );
                when 
                    1  => 
                    write_data <= ( THRESH_INACT & X"03"  );
                when 
                    2  => 
                    write_data <= ( TIME_INACT & X"01"  );
                when 
                    3  => 
                    write_data <= ( ACT_INACT_CTL & X"7f"  );
                when 
                    4  => 
                    write_data <= ( THRESH_FF & X"09"  );
                when 
                    5  => 
                    write_data <= ( TIME_FF & X"46"  );
                when 
                    6  => 
                    write_data <= ( BW_RATE & X"09"  );
                when 
                    7  => 
                    write_data <= ( INT_ENABLE & X"10"  );
                when 
                    8  => 
                    write_data <= ( INT_MAP & X"10"  );
                when 
                    9  => 
                    write_data <= ( DATA_FORMAT & X"40"  );
                when 
                     others  => 
                    write_data <= ( POWER_CONTROL & X"08"  );
            end case;
        end process;
        process 
        begin
            wait until ( ( iRSTN'EVENT and ( iRSTN = '0' )  )  or ( iSPI_CLK'EVENT and ( iSPI_CLK = '1' )  )  ) ;
            if ( (  not iRSTN )  ) then 
                ini_index <= '0';
                spi_go <= '0';
                spi_state <= IDLE;
                read_idle_count <= 0 ;
                high_byte <= '0';
                read_back <= '0';
                clear_status <= '0';
            else 
                if ( ( ini_index < INI_NUMBER )  ) then 
                    case  ( spi_state ) is 
                        when 
                            IDLE => 
                            p2s_data <= ( WRITE_MODE & write_data );
                            spi_go <= '1';
                            spi_state <= TRANSFER;
                        when 
                            TRANSFER => 
                            if ( spi_end ) then 
                                ini_index <= ( ini_index + '1' ) ;
                                spi_go <= '0';
                                spi_state <= IDLE;
                            end if;
                    end case;
                else 
                    case  ( spi_state ) is 
                        when 
                            IDLE => 
                            read_idle_count <= ( read_idle_count + 1  ) ;
                            if ( high_byte ) then 
                                p2s_data(15  downto 8 ) <= ( READ_MODE & X_HB );
                                read_back <= '1';
                            else 
                                if ( read_ready ) then 
                                    p2s_data(15  downto 8 ) <= ( READ_MODE & X_LB );
                                    read_back <= '1';
                                else 
                                    if ( ( ( (  not clear_status_d(3 ) )  and iG_INT2 )  or read_idle_count(IDLE_MSB) )  ) then 
                                        p2s_data(15  downto 8 ) <= ( READ_MODE & INT_SOURCE );
                                        clear_status <= '1';
                                    end if;
                                end if;
                            end if;
                            if ( ( ( ( high_byte or read_ready )  or read_idle_count(IDLE_MSB) )  or ( (  not clear_status_d(3 ) )  and iG_INT2 )  )  ) then 
                                spi_go <= '1';
                                spi_state <= TRANSFER;
                            end if;
                            if ( read_back_d ) then 
                                if ( high_byte_d ) then 
                                    oDATA_H <= s2p_data;
                                    oDATA_L <= low_byte_data;
                                else 
                                    low_byte_data <= s2p_data;
                                end if;
                            end if;
                        when 
                            TRANSFER => 
                            if ( spi_end ) then 
                                spi_go <= '0';
                                spi_state <= IDLE;
                                if ( read_back ) then 
                                    read_back <= '0';
                                    high_byte <= (  not high_byte ) ;
                                    read_ready <= '0';
                                else 
                                    clear_status <= '0';
                                    read_ready <= s2p_data(6 );
                                    read_idle_count <= 0 ;
                                end if;
                            end if;
                    end case;
                end if;
            end if;
        end process;
        process 
        begin
            wait until ( ( iRSTN'EVENT and ( iRSTN = '0' )  )  or ( iSPI_CLK'EVENT and ( iSPI_CLK = '1' )  )  ) ;
            if ( (  not iRSTN )  ) then 
                high_byte_d <= '0';
                read_back_d <= '0';
                clear_status_d <= '0';
            else 
                high_byte_d <= high_byte;
                read_back_d <= read_back;
                clear_status_d <= ( clear_status_d(2  downto 0 ) & clear_status );
            end if;
        end process;
    end; 


